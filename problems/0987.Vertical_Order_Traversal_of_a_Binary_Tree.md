[987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/)

* Hash Table, Tree, Binary Tree, Depth-First Search, Breadth-First Search
* Facebook, Amazon, DoorDash, Adobe, Google, Bloomberg, Apple, Microsoft, Oracle
* Similar Problems:
  * [314. Binary Tree Vertical Order Traversal](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)


## Method 1. DFS (2ms, beat 99%)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        // Run dfs() to add all TreeNodes into the list
        List<Location> locations = new ArrayList<>();
        dfs(root, 0, 0, locations);

        // Sort by x, y, and then val
        Collections.sort(locations);

        // Add the elements from left to right, top to down
        List<List<Integer>> res = new ArrayList<>();
        res.add(new ArrayList<Integer>());

        int prev = locations.get(0).x;  // the x position for the leftmost Location
        for(Location loc: locations) {
            if(loc.x != prev) {
                prev = loc.x;
                res.add(new ArrayList<Integer>());
            }
            res.get(res.size()-1).add(loc.val);
        }
        return res;
    }

    private void dfs(TreeNode root, int x, int y, List<Location> locations) {
        if(root != null) {
            locations.add(new Location(x, y, root.val));
            dfs(root.left, x - 1, y + 1, locations);
            dfs(root.right, x + 1, y + 1, locations);
        }
    }
}

class Location implements Comparable<Location> {
    int x;
    int y;
    int val;

    Location(int x, int y, int val) {
        this.x = x;
        this.y = y;
        this.val = val;
    }

    @Override
    public int compareTo(Location that) {
        if(this.x != that.x) {
            return Integer.compare(this.x, that.x);
        } else if(this.y != that.y) {
            return Integer.compare(this.y, that.y);
        } else {
            return Integer.compare(this.val, that.val);
        }
    }
}
```


## Method 2. BFS (3ms, beat 81%)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        
        // Corner case
        if(root == null) {
            return res;
        }

        // Normal case
        HashMap<Integer, List<Integer>> map = new HashMap<>();
        Queue<TreeNode> queue = new LinkedList<>();
        Queue<Integer> dis = new LinkedList<>();
        int min = 0;
        int max = 0;
        queue.offer(root);
        dis.offer(0);

        while(!queue.isEmpty()) {
            int size = queue.size();
            // 统计同一层上，不同偏移量都有哪些节点: <偏移量, List<Integer>>
            HashMap<Integer, List<Integer>> level = new HashMap<>();

            for(int i=0; i<size; i++) {
                TreeNode curr = queue.poll();
                int col = dis.poll();
                if(!level.containsKey(col)) {
                    level.put(col, new ArrayList<>());
                }
                level.get(col).add(curr.val);
                if(curr.left != null) {
                    queue.offer(curr.left);
                    dis.offer(col - 1);
                }
                if(curr.right != null) {
                    queue.offer(curr.right);
                    dis.offer(col + 1);
                }
                min = Math.min(min, col);
                max = Math.max(max, col);
            }

            // 把每一层上的节点加入最后的HashMap
            for(int key: level.keySet()) {
                if(!map.containsKey(key)) {
                    map.put(key, new ArrayList<>());
                }
                List<Integer> list = level.get(key);
                Collections.sort(list);
                map.get(key).addAll(list);
            }
        }

        for(int i=min; i<=max; i++) {
            res.add(map.get(i));
        }
        return res;
    }
}
```



## Reference
* 