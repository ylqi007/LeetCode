[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

* Array, Divide and Conquer, Dynamic Programming
* Google, Amazon, Microsoft, Bloomberg, Cisco, LinkedIn, Apple, Meta, Uber, Accenture, Infosys, TikTok, Oracle, PayPal, Adobe
* Similar Questions:
    * [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)    
    * [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)       
    * [697. Degree of an Array](https://leetcode.com/problems/degree-of-an-array/)
    * [978. Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)
    

## Method 1. currPrefixSum, maxPrefixSum
```java
/**
The sum of subarray ending with nums[i] depends on if we using the elements before nums[i].
 * if the prefixSum is larger than 0, we can use it.
 * if the prefixSum is less than 0, using it only makes the prefixSum smaller, so we abandon prefixSum < 0
 */
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length == 0) {
            return 0;
        }

        int maxSum = nums[0];
        int currSum = nums[0];
        for(int i=1; i<nums.length; i++) {
            currSum = Math.max(currSum, 0) + nums[i];
            maxSum = Math.max(maxSum, currSum);
        }
        return maxSum;
    }
}
```


## Method 2. preSum - minPreSum
```java
class Solution {
    public int maxSubArray(int[] nums) {
        // Corner case
        if(nums == null || nums.length == 0) {
            return 0;
        }

        int res = Integer.MIN_VALUE;
        int minPreSum = 0;
        int preSum = 0;
        for(int num: nums) {
            preSum += num;
            res = Math.max(res, preSum - minPreSum);
            minPreSum = Math.min(minPreSum, preSum);
        }
        return res;
    }
}
```
**å¤æ‚åº¦åˆ†æž:**
* æ—¶é—´å¤æ‚åº¦ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` ä¸º `nums` çš„é•¿åº¦ã€‚
* ç©ºé—´å¤æ‚åº¦ï¼š`O(1)`ã€‚ä»…ç”¨åˆ°è‹¥å¹²é¢å¤–å˜é‡ã€‚


## Method 2. Dynamic Programming, åŠ¨æ€è§„åˆ’
å®šä¹‰ `dp[i]` è¡¨ç¤ºä»¥ `nums[i]` ç»“å°¾çš„æœ€å¤§å­æ•°ç»„å’Œã€‚
* i = 0: `dp[i] = nums[i]`
* i > 0: `dp[i] = Math.max(dp[i-1], 0) + nums[i]`
```
class Solution {
    public int maxSubArray(int[] nums) {
        int[] f = new int[nums.length];
        f[0] = nums[0];
        int ans = f[0];
        for (int i = 1; i < nums.length; i++) {
            f[i] = Math.max(f[i - 1], 0) + nums[i];
            ans = Math.max(ans, f[i]);
        }
        return ans;
    }
}
```
**å¤æ‚åº¦åˆ†æž:**
* æ—¶é—´å¤æ‚åº¦ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` ä¸º `nums` çš„é•¿åº¦ã€‚
* ç©ºé—´å¤æ‚åº¦ï¼š`O(1)`ã€‚ä»…ç”¨åˆ°è‹¥å¹²é¢å¤–å˜é‡ã€‚


## Method 3. Divide and Conquer
```java
class Solution {
    public int maxSubArray(int[] nums) {
        return maxSubArray(nums, 0, nums.length - 1);
    }

    private int maxSubArray(int[] nums, int left, int right) {
        if(left > right) {
            return Integer.MIN_VALUE;
        }
        int mid = left + (right - left) / 2;
        int curr = 0;
        int maxLeftSum = 0;
        int maxRightSum = 0;

        // Iterate from the middle to the beginning
        for(int i=mid-1; i>=left; i--) {
            curr += nums[i];
            maxLeftSum = Math.max(maxLeftSum, curr);
        }

        curr = 0;
        for(int i=mid+1; i<=right; i++) {
            curr += nums[i];
            maxRightSum = Math.max(maxRightSum, curr);
        }

        int maxCombinedSum = maxLeftSum + nums[mid] + maxRightSum;
        int leftHalf = maxSubArray(nums, left, mid - 1);
        int rightHalf = maxSubArray(nums, mid + 1, right);

        return Math.max(maxCombinedSum, Math.max(leftHalf, rightHalf));
    }
}
```
**Complexity Analysis:**
* Time complexity: `O(Nâ‹…logN)`, where `N` is the length of `nums`.
* Space complexity: `O(logN)`, where `N` is the length of nums.



## Method 1. With a PreSum Array
Key Points:
1. When the sum of previous subarray is less than 0, then we start a new array.
2. `currSum = Math.max(prevSum, 0) + nums[i]`

æ‰«ææ•°ç»„ï¼Œå½“é‡åˆ°æŸä¸ªæ•°`nums[i]`çš„æ—¶å€™ï¼Œéœ€è¦åˆ¤æ–­`sums[i - 1]`æ˜¯å¦å°äºŽ0ã€‚å¦‚æžœå°äºŽ0ï¼Œ`nums[i] + sums[i - 1]`çš„ç»“æžœåªä¼šæ‹–ç´¯å½“å‰çš„`sums[i]`ï¼›å¦‚æžœå¤§äºŽ0ï¼Œå¯ä»¥å°†`sums[i] = sums[i - 1] + nums[i]`ã€‚æœ€åŽè¿”å›žè¿‡ç¨‹ä¸­æ‰¾åˆ°çš„æœ€å¤§çš„`sums[i]`å³å¯ã€‚

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] sums = new int[nums.length];
        sums[0] = nums[0];
        int res = sums[0];
        for(int i=1; i<nums.length; i++) {
            if(sums[i-1] < 0) {
                sums[i] = nums[i];
            } else {
                sums[i] = sums[i-1] + nums[i];
            }
            res = Math.max(res, sums[i]);
        }
        return res;
    }
}
```
**Complexity Analysis:**
1. Time: O(N)
2. Space: O(N)


## ðŸŸ© Method 2. With a variable
**ä¼˜åŒ–æ€è·¯:** è¿™ç§DPçš„æ€è·¯ä¹Ÿæœ‰èŠ‚çœç©ºé—´çš„åšæ³•ï¼Œå…¶å®žæˆ‘ä»¬å¹¶ä¸ä¸€å®šéœ€è¦çŸ¥é“æ¯ä¸ª`dp[i]`å€¼çš„å¤§å°ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨éåŽ†è¿‡ç¨‹ä¸­è®°å½•ä¸€ä¸‹æœ€å¤§çš„dpå€¼å³å¯ã€‚æ€è·¯ä¹Ÿæ˜¯å¾ˆç±»ä¼¼ï¼Œå¦‚æžœä¹‹å‰çš„å€¼`prev`å°äºŽ0ï¼Œä¸€å®šä¼šæ‹–ç´¯`curr`çš„ï¼Œæ‰€ä»¥`curr = nums[i]`ï¼›åä¹‹å¦‚æžœ`prev`å¤§äºŽ 0ï¼Œ`curr`å°±å˜ä¸º`nums[i] + prev`ã€‚æ¯æ¬¡ç”¨`res`è®°å½•ä¸€ä¸‹å½“å‰çš„å­æ•°ç»„çš„æœ€å¤§å€¼ä¹‹åŽï¼Œå°±å¯ä»¥æŠŠ`curr`èµ‹ç»™`prev`ä»¥è¾¾åˆ°èŠ‚çœç©ºé—´çš„ç›®çš„äº†ã€‚

Intuition: Pick the *locally* optimal move at each step, and that will lead to the *globally* optimal solution.         
The algorithm is general and straightforward: **Iterate over the array and update at each step is the standard set for such problems:**
* Current element;
* Current *local* maximum sum (at this given point);
* *Global* maximum sum seen so far.

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums==null || nums.length==0) {
            return 0;
        }
        
        int prev = 0;
        int res = Integer.MIN_VALUE;
        for(int num: nums) {
            if(prev <= 0) {
                prev = num;
            } else {
                prev += num;
            }
            res = Math.max(res, prev);
        }
        return res;
    }
}
```
or

## âœ…â­ Method 3. Optimized Space
```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length == 0) {
            return 0;
        }
        
        int currSum = nums[0];
        int maxSum = nums[0];
        for(int i=1; i<nums.length; i++) {
            currSum = Math.max(nums[i], currSum + nums[i]);
            maxSum = Math.max(maxSum, currSum);
        }
        return maxSum;
    }
}
```
**Complexity Analysis:**
1. Time complexity: `O(N)` since it's one pass along the array.
2. Space complexity: `O(1)`, since it's a constant space solution.


## [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)   Method 3. Dynamic Programming (Kadane's Algorithm)

There are two standard DP approaches suitable for arrays:
1. Constant space one. Move along the array and modify the array itself.
2. Linear space one. First move in the direction `left -> right`, then in the direction `right -> left`. 
Combine the result, for example, [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

Key Points:
1. Def: `dp[i]` represents the largest sum ended at index `i`, it could be the sum of any subarray ended at index `i`;
2. Relation: `dp[i] = arr[i] + (dp[i-1] > 0 ? dp[i-1] : 0);`, i.e. when the preSum larger than 0, we can add `arr[i]` to previous subarray, else we need discard previous subarray and restart from `arr[i]`.
3. Initialization: `dp[0] = nums[0]`.

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length == 0) {
            return 0;
        }
        
        int maxSum = nums[0];
        for(int i=1; i<nums.length; i++) {
            if(nums[i-1] > 0) {
                nums[i] += nums[i-1];
            }
            maxSum = Math.max(maxSum, nums[i]);
        }
        return maxSum;
    }
}
```
**Complexity Analysis:**
1. Time complexity: `O(N)` since it's one pass along the array.
2. Space complexity: `O(1)`, since it's a constant space solution.


## Method 4. Divide and Conquer
> Let's follow here a solution template for the divide and conquer problmes:
> 1. Define the base case(s).
> 2. Split the problem into sub-problems and solve them recursively.
> 3. Merge the solutions for the sub-problems to obtain the solution for the original problem

Key Points:
1. Since the range is `[left, right]`, `mid = (right - left) / 2 + left`, i.e. the `len(subLeft) <= len(subRight)`;
2. For example: `[left, right] = [0, 1]`, the `mid = (1 - 0) / 2 + 0 = 0`. If we set `for(int i=mid-1; i>=left; i--) {...}` 
    * Iterate over `[0, 0)` ==> Not even one iteration, then `leftMaxSum = Integer.MIN_VALUE`
    * Iterate over `[0, 1]`
3. If we set `for(int i=mid; i>=left; i--) {...}`
    * Iterate over `[0, 0]` ==> At least one iteration.
    * Iterate over `(0, 1]` ==> At least one iteration.
```java
class Solution {
    public int maxSubArray(int[] nums) {
        return maxSubArray(nums, 0, nums.length-1);
    }
    
    // The max sum for the subarray `nums[left, ..., right]`
    public int maxSubArray(int[] nums, int left, int right) {
        if(left == right) {
            return nums[left];
        }
        int mid = (right - left) / 2 + left;
        int leftMaxSum = maxSubArray(nums, left, mid);
        int rightMaxSum = maxSubArray(nums, mid+1, right);
        int maxCrossSum = crossSubArray(nums, left, right, mid);
        
        return Math.max(maxCrossSum, Math.max(leftMaxSum, rightMaxSum));
    }
    
    public int crossSubArray(int[] nums, int left, int right, int mid) {
        if(left == right) {
            return nums[left];
        }
        
        int currSum = 0;
        int maxLeftSum = Integer.MIN_VALUE;
        // Max subarray sum: from right -> left
        for(int i=mid; i>=left; i--) {
            currSum += nums[i];
            maxLeftSum = Math.max(maxLeftSum, currSum);
        }
        
        currSum = 0;
        int maxRightSum = Integer.MIN_VALUE;
        // Max subarray sum: from left -> right
        for(int i=mid+1; i<=right; i++) {
            currSum += nums[i];
            maxRightSum = Math.max(maxRightSum, currSum);
        }
        
        return maxLeftSum + maxRightSum;
    }
}
```
**Complexity Analysis**
1. Time complexity: `O(NlogN)`.
2. Space complexity: `O(logN)` to keep the recursion stack. 


## Reference
* [CNoodle: [LeetCode] 53. Maximum Subarray](https://www.cnblogs.com/cnoodle/p/11776540.html)
* [åŠ›æ‰£: ç»å…¸åŠ¨æ€è§„åˆ’é—®é¢˜ï¼ˆç†è§£ã€Œæ— åŽæ•ˆæ€§ã€ï¼‰](https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)
* LeetCodeCN, çµèŒ¶å±±è‰¾åºœ: [ä¸¤ç§æ–¹æ³•ï¼šå‰ç¼€å’Œ/åŠ¨æ€è§„åˆ’ï¼ˆPython/Java/C++/C/Go/JS/Rustï¼‰](https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/)