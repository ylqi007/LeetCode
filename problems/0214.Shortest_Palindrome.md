[214. Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/)

* String, Rolling Hash, String Matching, Hash Function
* Google, Microsoft, Amazon, Accenture, Bloomberg, Meta, TikTok, Pocket Gems, Uber, Apple, Adobe, eBay
* Similar Questions:
    * [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)
    * Implement strStr()
    * [336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/)


## Method 1. Brute Force
> We can find the largest segment from the beginning which is a palindrome, and we can then easily reverse the remaining segment and append to the beginning.        
> æ‰¾åˆ° string ä¸­ä»Žå¤´å¼€å§‹çš„æœ€å¤§çš„ palindromeï¼Œé‚£ä¹ˆå°†å‰©ä¸‹çš„ segment reverseï¼Œæ·»åŠ åˆ° string çš„å¼€å¤´å°±å¥½äº†ã€‚          
> Example: `str = "abcbabcab"`, the largest palindrome segment from beginnings is `"abcba"`, and the remaining segment is `"bcab"`.
> Hence the shortest palindrome should be `reverse("bcab") + "abcba" + "bcab"`      

For example: `str = "abcd"` , `reverse = "dcba"`        
1. `i = 0`, `s.substring(0, 4)="abcd"`, `r.substring(0)="dcba"` ==> false
2. `i = 1`, `s.substring(0, 3)="abc"`, `r.substring(1)="cba"` ==> false
3. `i = 2`, `s.substring(0, 2)="ab"`, `r.substring(2)="ba"` ==> false
4. `i = 3`, `s.substring(0, 1)="a"`, `r.substring(1)="a"` ==> true

```java
class Solution {
    public String shortestPalindrome(String s) {
        int N = s.length();
        String rev = new StringBuilder(s).reverse().toString();
        for(int i=0; i<N; i++) {
            if(s.substring(0, N-i).equals(rev.substring(i))) {
                return rev.substring(0, i) + s;
            }
        }
        return "";
    }
}
```
**Complexity Analysis:**
1. Time complexity: `O(n^2)`.
    We iterate over the entire length of string sss.
    In each iteration, we compare the substrings which is linear in size of substrings to be compared.
    Hence, the total time complexity is O(nâˆ—n)=O(n^2).
2. Space complexity: O(n) extra space for the reverse string rev.

è¿™ç¯‡å¸–å­ä¸­çš„è§£é‡Šå¾ˆæ¸…æ¥š: [ã€Œæ‰‹ç”»å›¾è§£ã€ä»Žç®€å•çš„æš´åŠ›æ³•æƒ³åˆ° KMP](https://leetcode.cn/problems/shortest-palindrome/solutions/392676/shou-hua-tu-jie-cong-jian-dan-de-bao-li-fa-xiang-d/)


## Method 2. Two Pointers and Recursion (2ms, beats 100%)
> We could make the process more efficient if we could reduce the size of string to search for the substring without checking the complete substring each time.              
> 
> The proof of correction is that: Say the string was a perfect palindrome, `i` would be increased `n` times.       
> Hence, even though there is a chance that the range `[0,i)` is not always tight, it is ensured that it will always contain the longest palindrome from the beginning.     

Key Points:
1. å› ä¸ºè¦åœ¨ string `s` ä¹‹å‰æ·»åŠ  charactersï¼Œæ‰€ä»¥è¦æ‰¾çš„æœ€é•¿çš„ palindrome åªèƒ½æ˜¯ä»Ž string `s` çš„å¼€å¤´å¼€å§‹ï¼›
2. `[0, i)` represents the subarray which contains the possible longest palindrome.  
```java
class Solution {
    public String shortestPalindrome(String s) {
        if(s == null || s.length() == 0) {
            return s;
        }

        int N = s.length();
        // Find the longest palindromic prefix
        int i = 0;
        for(int j=N-1; j>=0; j--) {
            if(s.charAt(i) == s.charAt(j)) {
                i++;
            }
        }

        // If the whole string is a palindrome, return the original string
        if(i == N) {
            return s;
        }

        // Extract the suffix that is not part of the palindromic prefix 
        String nonPalindromeSuffix = s.substring(i);
        StringBuilder reverseSuffix = new StringBuilder(nonPalindromeSuffix).reverse();

        // Form the shortest palindrome by prepending the reversed suffix
        return reverseSuffix
                .append(shortestPalindrome(s.substring(0, i)))
                .append(nonPalindromeSuffix)
                .toString();
    }
}
```
**Complexity analysis:**
1. Time complexity: `O(n^2)`. 
2. Space complexity: `O(n)` extra space for `remain_rev` string.        


## Method 3. KMP
> We have seen that the question boils down to finding the largest palindrome substring from the beginning.     


## Reference:
1. [Solution](https://leetcode.com/problems/shortest-palindrome/solution/)
2. [Solve LeetCode 214 Shortest Palindrome by FFT](https://hackmd.io/@YuzwqJGwRa6CIN12AneRxg/HkBxRYbrN?type=view)
3. LeetCodeCN åŠ›æ‰£å®˜æ–¹é¢˜è§£: https://leetcode.cn/problems/shortest-palindrome/solutions/392561/zui-duan-hui-wen-chuan-by-leetcode-solution/
4. ðŸŸ©ðŸŒŸLeetCodeCN: https://leetcode.cn/problems/shortest-palindrome/solutions/392676/shou-hua-tu-jie-cong-jian-dan-de-bao-li-fa-xiang-d/
