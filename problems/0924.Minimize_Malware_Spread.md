[924. Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

* Array, Graph, Hash Table, DFS, BFS, Union Find
* Saleforce, TikTok, Dropbox
* Similar Quesitons:


## Method 1. DFS
This algorithm has a few parts:
1. Coloring each component: For each node, if it isn't yet colored, use a depth-first search to traverse its component, coloring that component with a new color.
2. Size of each color: Count the number of occurrences of each color.
3. Find unique colors: Look at the colors of nodes in initial to see which nodes have unique colors.
4. Choose answer: For each node with a unique color, find the size of that color. The largest size is selected, with ties broken by lowest node number. 
   * If there is no node with a unique color, the answer is min(initial).


我们可以分别考虑每一个连通分量：
* 如果其中没有感染节点，那么无需考虑；
* 如果其中恰好有一个感染节点，移除该节点可以使得最终感染的节点数减少，减少的值即为该连通分量的大小；
* 如果其中有超过一个感染节点，那么无论移除哪一个节点，剩下的那个（那些）节点总会感染连通分量中的所有节点，同样无需考虑。


**Key Points:**
1. Color each node so that connected nodes are the same color;
2. Count the frequency of each color;
3. Find the unique color in initial nodes. If there have two nodes with same color in initial nodes, 
then only remove one of them has no effect on stopping spread.
4. Only consider initial node with unique color.

```java
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // 1. Color each node
        int N = graph.length;
        int[] colors = new int[N];
        Arrays.fill(colors, -1);
        int C = 0;  // The initial color
        for(int i=0; i<N; i++) {
            if(colors[i] == -1) {
                dfs(graph, colors, i, C);
                C++;
            }
        }
        
        // 2. Count each color
        int[] size = new int[C];
        for(int color: colors) {
            size[color]++;
        }
        
        // 3. Find unique color
        int[] colorCount = new int[C];
        for(int node: initial) {    // node is malware node
            colorCount[colors[node]]++;
        }
        
        // 4. 
        int ans = Integer.MAX_VALUE;
        for(int node: initial) {
            int c = colors[node];
            if(colorCount[c] == 1) {
                if(ans == Integer.MAX_VALUE) {
                    ans = node;
                } else if(size[c] > size[colors[ans]]) {
                    ans = node;
                } else if(size[c]==size[colors[ans]] && node<ans) {
                    ans = node;
                }
            }
        }
        
        if(ans == Integer.MAX_VALUE) {
            for(int node: initial) {
                ans = Math.min(ans, node);
            }
        }
        return ans;
    }
    
    private void dfs(int[][] graph, int[] colors, int node, int color) {
        colors[node] = color;
        for(int nei=0; nei<graph.length; nei++) {
            if(graph[node][nei]==1 && colors[nei]==-1) {
                dfs(graph, colors, nei, color);
            }
        }
    }
}
```
**Complexity Analysis:**
1. Time Complexity: `O(N^2)`, where NNN is the length of graph, as the graph is given in adjacent matrix form.
2. Space Complexity: `O(N)`.


## Method 2. Union-Find (5ms, beats 87%)
1. Union found all nodes.
   * Count the union size of each union set.
   * Count the malware number of each union set.
2. Return the biggest union's malware if there is one and only one malware.
   * If no such union that has and has only one malware,
   * return the malware with minimum index.
  
```java
class Solution {
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        UnionFind uf = new UnionFind(n);
        for(int i=0; i<n; i++) {
            for(int j=i+1; j<n; j++) {
                if(graph[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }
        
        int[] count = new int[n];
        for(int node: initial) {
            count[uf.find(node)]++;
        }
        
        int ans = -1;
        int ansSize = -1;
        for(int node: initial) {
            int root = uf.find(node);
            if(count[root] == 1) {  // Unique color
                int rootSize = uf.size(root);
                if(rootSize > ansSize) {
                    ansSize = rootSize;
                    ans = node;
                } else if(rootSize == ansSize && node < ans) {
                    ansSize = rootSize;
                    ans = node;
                }
            }
        }
        
        if(ans == -1) {
            ans = Integer.MAX_VALUE;
            for(int node: initial) {
                ans = Math.min(ans, node);
            }
        }
        return ans;
    }
}

class UnionFind {
    int[] parent;
    int[] size;
    
    public UnionFind(int n) {
        parent = new int[n];
        size = new int[n];
        for(int i=0; i<n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    public int find(int x) {
        if(parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    public void union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if(px != py) {
            if(size[px] > size[py]) {
                parent[py] = px;
                size[px] += size[py];
            } else {
                parent[px] = py;
                size[py] += size[px];
            }
        }
    }
    
    public int size(int x) {
        return size[find(x)];
    }
}
```

or 

```java
class Solution {
    
    private int[] p;

    public int minMalwareSpread(int[][] g, int[] initial) {
        int n = g.length;
        p = new int[n];
        for (int i = 0; i < n; i++) p[i] = i;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (g[i][j] == 1) union(i, j);
        int[] ufSize = new int[n];
        int[] malCount = new int[n];
        for (int i = 0; i < n; i++) ufSize[find(i)]++;
        for (int init : initial) malCount[find(init)]++;
        // for maximum ufSize, if malware count is 1, return that index
        int res = -1;
        int maxSize = 0;
        Arrays.sort(initial);
        for (int init : initial) {
            int idx = find(init);
            if (malCount[idx] == 1 && ufSize[idx] > maxSize) {
                maxSize = ufSize[idx];
                res = init;
            }
        }
        if (maxSize != 0) return res;
        else return initial[0];
    }

    private void union(int i, int j) {
        p[find(i)] = find(j);
    }

    private int find(int i) {
        if (p[i] == i) return i;
        else {
            p[i] = find(p[i]);
            return p[i];
        }
    }
}
``` 
Complexity Analysis
1. Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
2. Space Complexity: O(N). 


## Reference
1. [[C++/Python] Union Found](https://leetcode.com/problems/minimize-malware-spread/discuss/181129/C%2B%2BPython-Union-Found)

