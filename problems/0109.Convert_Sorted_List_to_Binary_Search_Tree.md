[109. Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)

* LinkedList, Tree, Binary Tree, Binary Search Tree, Divide and Conquer
* Zenefits, Amazon, Microsoft, Google, Meta, Bloomberg, Uber, Lyft
* Similar Questions:
    * [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)
    * [1382. Balance a Binary Search Tree](https://leetcode.com/problems/balance-a-binary-search-tree/description/)


108å’Œ109æ€è·¯æ˜¯ç›¸åŒçš„ï¼Œéƒ½æ˜¯**é€’å½’**: åŒºåˆ«åœ¨äº108å¯ä»¥é€šè¿‡**æ‰¾ä¸­ç‚¹**çš„åŠæ³•å¿«é€Ÿæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œä½†æ˜¯109åªèƒ½é€šè¿‡**å¿«æ…¢æŒ‡é’ˆ**çš„åŠæ³•æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œ
* 108æ˜¯ä»**æœ‰åºæ•°ç»„**è½¬åŒ–æˆBSTï¼Œ
* 109æ˜¯ä»æœ‰åºé“¾è¡¨è½¬åŒ–æˆBSTã€‚


## Method 1. Find middle node as root node
```java
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        if(head == null) {
            return null;
        }
        ListNode mid = findMiddleElement(head);
        
        TreeNode root = new TreeNode(mid.val);
        if(head == mid) {
            return root;
        }
        
        root.left = sortedListToBST(head);
        root.right = sortedListToBST(mid.next);
        return root;
    }
    
    private ListNode findMiddleElement(ListNode head) {
        ListNode prev = null;
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null && fast.next!=null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        
        if(prev != null) {
            prev.next = null;
        }
        return slow;
    }
}
```


## ğŸŸ© Method 2. Fast/Slow Pointers
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return buildTree(head, null);   // [head, tail), i.e include head, exclude tail
    }

    private TreeNode buildTree(ListNode head, ListNode tail) {
        if(head == tail) {
            return null;
        }

        ListNode slow = head;
        ListNode fast = head;
        while(fast != tail && fast.next != tail) {
            slow = slow.next;
            fast = fast.next.next;
        }

        TreeNode root = new TreeNode(slow.val);
        root.left = buildTree(head, slow);
        root.right = buildTree(slow.next, tail);
        return root;
    }
}
```
**Complexity Analysis:**
1. æ—¶é—´O(n)
2. ç©ºé—´O(n)


## Reference
* https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/editorial/
* [CNoodle: [LeetCode] 109. Convert Sorted List to Binary Search Tree](https://www.cnblogs.com/cnoodle/p/12293684.html)