[139. Word Break](https://leetcode.com/problems/word-break/)

* Array, String, Hash Table, Trie, Dynamic Programming, Memoization
* Amazon, Meta, Microsoft, Google, Bloomberg, Walmart Labs, Uber, TikTok, Salesforce, Coupang, Yahoo, Block, MongoDB, Pocket Gems, Apple, Adobe, Tesla, Oracle
* Similar Questions:
    * [140. Word Break II](https://leetcode.com/problems/word-break-ii/)
    

## é¢˜æ„åˆ†æ
* Given non-empty string `s` and a list of non-empty `words`: åˆ¤æ–­ string `s` æ˜¯å¦å¯ä»¥ç”± `words` ä¸­çš„å•è¯ç»„æˆã€‚
* DP formula: `dp[j] = dp[i] && wordExist(s.substring(i,j))`


## Method 1. [Java DP solution](https://leetcode.com/problems/word-break/discuss/44054/Java-DP-solution)
**è¦ç‚¹:**
* [qurrat](https://leetcode.com/problems/word-break/discuss/44054/Java-DP-solution/208211)
ç”¨ `boolean[] dp` å»æ ‡è®°ç‰¹å®šé•¿åº¦çš„ prefix substring æ˜¯å¦å¯ä»¥ç”¨ `dict` ä¸­çš„å•è¯æˆåŠŸåˆ†è§£ã€‚      
* `dp[0]` ä»£è¡¨çš„æ˜¯ empty string, ä½œä¸ºæœ€åŸºæœ¬çš„ caseï¼Œ`dp[0] = true`;      
* `dp[1]` ä»£è¡¨çš„æ˜¯ `s.substring(0, 1)` æ˜¯å¦å¯ä»¥è¢«æˆåŠŸåˆ†è§£ï¼Œå½“ç„¶æ­¤æ—¶ `s.substring(0, 1) == ""`;      
* `dp[2]` ä»£è¡¨çš„æ˜¯ `s.substring(0, 2)` æ˜¯å¦å¯ä»¥è¢«æˆåŠŸåˆ†è§£ï¼Œå½“ç„¶æ­¤æ—¶ `s.substring(0, 2)` æ˜¯ String s çš„ç¬¬ä¸€ä¸ªå­—æ¯ã€‚
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> dict = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length() + 1]; // DP array to store previous results
        dp[0] = true;   // default value
        
        for(int i=1; i<=s.length(); i++) {  // dp[i] represents if s.substring(0, i) can be break
            for(int j=0; j<i; j++) {
                if(dp[j] && dict.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```
**Complexity Analysis:**
1. Time Complexity: `O(n^3)` since substring() in Java version > 7 takes `O(n)` time.
2. Space complexity: `O(n)`. Length of ppp array is n+1.


## ğŸŸ© Method 1. Optimized version: (1ms, beats 99%)
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        int len = 0;
        int n = s.length();

        for(String ss: wordDict) {
            set.add(ss);
            len = Math.max(ss.length(), len);
        }

        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for(int i=0; i<=n; i++) {
            if(dp[i] == false) {    // æå‰skipä¸€äº›ä¸å¯èƒ½çš„æƒ…å†µ
                continue;
            }

            for(int l=1; l<=len && l+i<=n; l++) {   // åªè€ƒè™‘å¯èƒ½çš„æœ€é•¿æƒ…å†µ
                String substr = s.substring(i, i+l);
                if(set.contains(substr)) {
                    dp[i+l] = true;
                }
            }
        }
        return dp[n];
    }
}
```
* https://leetcode.com/problems/word-break/submissions/1226226812/


## ğŸŸ©ğŸŒŸ Method 2. Top-Down Dynamic Programming Fastest (1ms, beats 99%)
Key Points:
1. `Boolean[] visited`, this Boolean array is just represent `s[idx, s.length()]` has been analyzed or not.
2. Example:
            str =  "l e e t c o d e", wordDict = ["leet", "code"]
            vis = T n n n n n n n n
                  T T n n n _ n n n , s.indexOf("leet", 0) = 0
                  T T n n n _ n n n , wordBreak(s, 4, dict, visited), 
                  T T n n n T n n n , word="code", idx=4+4=8, ==> return true;
3. åœ¨ `private boolean wordBreak(String s, int idx, List<String> wordDict, Boolean[] visited)` ä¸­ï¼Œè¿”å› `true` çš„å”¯ä¸€ä¸¤ç§æƒ…å†µæ˜¯ï¼š
    1. `idx == s.length()`, i.e. find the whole string `s` can be broke.
    2. `wordBreak(s, idx+word.length(), dict, visited)` return true. ä¹Ÿå°±æ˜¯ string `s` ä»¥ `word` å¼€å¤´ï¼Œå¹¶ä¸”å‰©ä¸‹çš„éƒ¨åˆ†å¯ä»¥è¢« brokeã€‚
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        return wordBreak(s, 0, wordDict, new Boolean[s.length() + 1]);
    }
    
    private boolean wordBreak(String s, int idx, List<String> wordDict, Boolean[] visited) {
        if(idx == s.length()) {
            return true;
        }
        visited[idx] = true;
        for(String word: wordDict) {
            if(s.indexOf(word, idx)==idx && visited[idx+word.length()]==null) { // ç”¨ memo æ ‡è®°çš„å½¢å¼æ˜¯å¯ä»¥é¿å… time limit exceeded
                if(wordBreak(s, idx+word.length(), wordDict, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
}
```
**Complexity Analysis:**
Given `n` as the length of s, `m` as the length of wordDict, and `k` as the average length of the words in wordDict,
1. Time complexity: `O(nâ‹…mâ‹…k)`
    * There are `n` states of `dp(i)`. Because of memoization, we only calculate each state once. To calculate a state, we iterate over `m` words, and for each word perform some substring operations which costs `O(k)`. Therefore, calculating a state costs `O(mâ‹…k)`, and we need to calculate `O(n)` states.
2. Space complexity: `O(n)`
    * The data structure we use for memoization and the recursion call stack can use up to `O(n)` space.


## Method 3. Recursion with Memoization (Faster)
Intuition:
1. To avoid calling recursive function multiple times for a particular string, we can use memoization method, where an array `memo` is used to store the result of the subproblems.
2. When the function is called again for a particular string, value will be fetched and returned using the `memo` array, if its value has been already evaluated.
3. With memoization many redundant subproblems are avoid and recursion tree is pruned and thus it reduces the time complexity by a large factor.

Key Points:
1. æ­¤å¤„çš„ `new Boolean[s.length()]` ç”¨çš„æ˜¯ `Boolean[]` array, å› ä¸ºè¦åœ¨ `memo[idx] != null` çš„æ—¶å€™ `return memo[idx]`;
2. `wordBreak(String s, Set<String> dict, int start, Boolean[] memo)` return `true/false`, representing whether or not the substring `s[start, s.length()-1]` can be represented by
    * `wordBreak()` å‡½æ•°ä¸­çš„ `start` ä½œä¸ºè¦ `word` å¼€å§‹çš„ index(inclusive), 
    * for-loop ä¸­ `end` index(exclusive).
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        return wordBreak(s, new HashSet<String>(wordDict), 0, new Boolean[s.length()]);
    }
    
    public boolean wordBreak(String s, Set<String> dict, int start, Boolean[] memo) {
        if(start == s.length()) {
            return true;
        }
        if(memo[start] != null) {
            return memo[start];
        }
        
        for(int end=start+1; end<=s.length(); end++) {
            if(dict.contains(s.substring(start, end)) && wordBreak(s, dict, end, memo)) {
                memo[start] = true;
                return memo[start];
            }
        }
        memo[start] = false;
        return memo[start];
    }
}
```
Complexity Analysis
1. Time complexity : `O(n^2)`. Size of recursion tree can go up to `n^2`.
2. Space complexity : `O(n)`. The depth of recursion tree can go up to `n`. 
   

### My Solution: Time Limit Exceeded
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        return wordBreak(s, 0, wordDict);
    }
    
    private boolean wordBreak(String s, int idx, List<String> dict) {
        if(idx == s.length()) {
            return true;
        }
        for(String word: dict) {
            if(s.indexOf(word, idx) == idx && (dict.contains(s.substring(idx + word.length())) || wordBreak(s, idx+word.length(), dict))) {
                return true;
            }
        }
        return false;
    }
}
```

Unpassed Example:

    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
    ["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ"aaa...aaa" é¦–å…ˆä¼šä¸€ç›´åˆ†è§£å‡ºä¸€ä¸ª "a"ï¼Œç„¶åå¤šæ¬¡è¿­ä»£ï¼Œä»è€Œæ—©ä» Time Limit Exceeded.     
æ¯”å¦‚åœ¨ç”¨ "a" åˆ†è§£ "aaa...aab" çš„æ—¶å€™ï¼Œåªæœ‰æœ€åä¸€ä¸ª "b" æ²¡æœ‰åŒ¹é…ï¼Œç„¶åç”¨ "aa" è¿›è¡Œåˆ†è§£çš„æ—¶å€™ï¼Œåˆè¦é‡æ–°å¼€å§‹ï¼Œå¯¹äº "aaa" ä¹Ÿæ˜¯åŒç†ã€‚      
å¦‚æœç”¨ä¸€ä¸ª `visited` array å»æ ‡è®°å·²ç»è®¿é—®è¿‡çš„ï¼Œå¹¶ä¸”èƒ½æˆåŠŸåˆ†è§£çš„ prefixã€‚

* ç”¨ä¸€ä¸ª `memo` è®°å½•è®¿é—®è¿‡çš„ positionï¼Œä¸‹æ¬¡å°±ä¸ç”¨å†æ¬¡è®¿é—®äº†ï¼Œä»è€Œé¿å…æ—¶é—´ä¸Šçš„ wasteã€‚

Complexity Analysis
1. Time complexity : `O(n^n)`. Consider the worst case where sss = "aaaaaaa" and every prefix of sss is present in the dictionary of words, then the recursion tree can grow upto `n^n`.
2. Space complexity : `O(n)`. The depth of the recursion tree can go upto `n`.


## Reference
1. [Java Common template - Word Break I, Word Break II, Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/348972/Java-Common-template-Word-Break-I-Word-Break-II-Concatenated-Words)
2. [Java DP solution](https://leetcode.com/problems/word-break/discuss/44054/Java-DP-solution)
3. https://leetcode.com/problems/word-break/submissions/1226231020/
4. [CNoodle: [LeetCode] 139. Word Break](https://www.cnblogs.com/cnoodle/p/12880007.html)
5. LeetCodeCN: https://leetcode.cn/problems/word-break/solutions/302471/dan-ci-chai-fen-by-leetcode-solution/