[721. Accounts Merge](https://leetcode.com/problems/accounts-merge/)

* Array, String, Hash Table, Sorting, Union Find, DFS, BFS
* Meta, Google, Microsoft, Amazon, Snap, Apple, TikTok, PhonePe, Adobe, Databricks
* Similar Questions
   * [734. Sentence Similarity](https://leetcode.com/problems/sentence-similarity/)
   * [737. Sentence Similarity II](https://leetcode.com/problems/sentence-similarity-ii/)
   * [684. Redundant Connection](https://leetcode.com/problems/redundant-connection/)
* Hints:
    * For every pair of emails in the same account, draw an edge between those emails. The problem 
    is about enumerating the connected components of this graph.
    

1. Two accounts definitely belong to the same person if there is some email that is common to both accounts. å¦‚æœæœ‰äººå±äºåŒä¸€ä¸ª emailï¼Œåˆ™æ˜¯åŒä¸€ä¸ª accountã€‚ 
2. Note that even if two accounts have the same name, they may belong to different people as people could have the same name.
3. A person can have any number of accounts initially, but all of their accounts definitely have the same name.

Analysis:
1. HashMap: email -> name
2. HashMap: email -> primary email, i.e. the first email of each account


âš ï¸æ³¨æ„:
1. æ˜¯å¦æœ‰common emailæ˜¯åˆ¤æ–­ä¸¤ä¸ªaccountæ˜¯å¦å±äºåŒä¸€ä¸ªnameçš„æ ‡å‡†ã€‚
2. UnionFindè¦unionçš„å¯¹è±¡æ˜¯emailï¼Œä½†æ˜¯emailåˆæ— æ³•ç›´æ¥åšunionï¼Œæ‰€ä»¥è¦å°†email mapping to Id


## ğŸŸ©Method 1. Union Find (37ms, beats 40%)
Key Points:
1. Map each email to its owner, i.e. `email --> name`, each email just have one name, and more than one email could have the same name;
2. Map each email to a unique id;
3. Union email to the first email in its account, after union, the emails in the same component will have the same parent id;
4. Put the emails have the same parent id into the same account.
5. Sort and add name to each list.
6. æ¯ä¸ª email åªèƒ½æœ‰ä¸€ä¸ª unique idï¼›
7. æ¯ä¸ª account çš„ç¬¬ä¸€ä¸ª email æ˜¯ primary emailï¼Œi.e. æ˜¯è¿™ä¸ª component çš„ rootã€‚
```java
class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        UnionFind uf = new UnionFind(10000);
        Map<String, String> emailToName = new HashMap<>();  // email --> name
        Map<String, Integer> emailToID = new HashMap<>();   // email --> email ID 

        int id = 0;
        for(List<String> account: accounts) {
            String name = "";
            for(String email: account) {
                if(name == "") {
                    name = email;
                    continue;
                }
                emailToName.put(email, name);
                if(!emailToID.containsKey(email)) { // make sure each email just has one and only one ID
                    emailToID.put(email, id++);
                }
                uf.union(emailToID.get(account.get(1)), emailToID.get(email));
            }
        }

        Map<Integer, List<String>> res = new HashMap<>();
        for(String email: emailToName.keySet()) {
            int idx = uf.find(emailToID.get(email));     // The emails belong to one component have the same ID
            if(!res.containsKey(idx)) {
                res.put(idx, new ArrayList<>());
            }
            res.get(idx).add(email);
        }

        for(List<String> emails: res.values()) {
            Collections.sort(emails);
            emails.add(0, emailToName.get(emails.get(0)));
        }
        return new ArrayList<>(res.values());
    }
}

class UnionFind {
    int[] parent;

    public UnionFind(int n) {
        parent = new int[n];
        for(int i=0; i<n; i++) {
            parent[i] = i;
        }
    }

    public int find(int x) {
        if(parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    public void union(int x, int y) {
        parent[find(x)] = find(y);
    }
}
```
**Complexity Analysis:** Here `N` is the number of accounts and `K` is the maximum length of an account.
* Time complexity: `O(NKlogNK)`
* Space complexity: `O(NK)`


## Method 1. Graph + DFS
Key Points:
1. æœ¬é¢˜å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ª graph problemã€‚åŒä¸€ä¸ªäººçš„ email éƒ½ç›¸è¿ï¼Œç„¶ååš DFS å°±å¯ä»¥æ‰¾åˆ°æ‰€æœ‰ç›¸è¿çš„ emailã€‚
2. ç”¨ Map + List è¡¨ç¤º graphï¼Œi.e. adjacent list:
   ```java
   // 2. Connect all emails with the first email: Since all emails in an account are connected, we can add an edge between every pair of emails. 
   graph.computeIfAbsent(email, x -> new ArrayList<String>()).add(account.get(1));
   // 3. Make sure the first email connect with all other emails.
   graph.computeIfAbsent(account.get(1), x -> new ArrayList<String>()).add(email);
   ```
3. ç„¶åè¿›è¡Œ Depth First Search

   ```java
   for(String email: graph.keySet()) {		// DFS
       if(!seen.contains(email)) {
           seen.add(email);
           Deque<String> stack = new ArrayDeque<>();
           stack.push(email);
           List<String> component = new ArrayList<>();
           while(!stack.isEmpty()) {
               String node = stack.pop();
               component.add(node);
               for(String nei: graph.get(node)) {
                   if(!seen.contains(nei)) {
                       seen.add(nei);
                       stack.push(nei);
                   }
               }
           }
           Collections.sort(component);
           component.add(0, emailToName.get(email));
           res.add(component);
       }
   }
   ```

   

```java
class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        Map<String, String> emailToName = new HashMap<>();
        Map<String, ArrayList<String>> graph = new HashMap<>();
        for(List<String> account: accounts) {
            String name = "";
            for(String email: account) {    // the first email actually is name
                if(name == "") {    // this si the first string, i.e. name
                    name = email;
                    continue;
                }
                // 1. map email to name
                emailToName.put(email, name);
                // 2. Connect all emails with the first email 
                graph.computeIfAbsent(email, x -> new ArrayList<String>()).add(account.get(1));
                // 3. Make sure the first email connect with all other emails.
                graph.computeIfAbsent(account.get(1), x -> new ArrayList<String>()).add(email);
            }
        }
        
        Set<String> seen = new HashSet<>();
        List<List<String>> res = new ArrayList<>();
        for(String email: graph.keySet()) {		// DFS
            if(!seen.contains(email)) {
                seen.add(email);
                Deque<String> stack = new ArrayDeque<>();
                stack.push(email);
                List<String> component = new ArrayList<>();
                while(!stack.isEmpty()) {
                    String node = stack.pop();
                    component.add(node);
                    for(String nei: graph.get(node)) {
                        if(!seen.contains(nei)) {
                            seen.add(nei);
                            stack.push(nei);
                        }
                    }
                }
                Collections.sort(component);
                component.add(0, emailToName.get(email));
                res.add(component);
            }
        }
        return res;
    }
}
```

or more clear way

```java
class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        // Build graph
        Map<String, String> emailToName = new HashMap<>();
        Map<String, List<String>> graph = new HashMap<>();
        for(List<String> account: accounts) {
            String name = "";
            for(String email: account) {
                if(name == "") {
                    name = email;
                    continue;
                }
                // Email --> Name
                emailToName.put(email, name);
                // Build graph
                if(!graph.containsKey(account.get(1))) {
                    graph.put(account.get(1), new ArrayList<>());
                }
                graph.get(account.get(1)).add(email);
                if(!graph.containsKey(email)) {
                    graph.put(email, new ArrayList<>());
                }
                graph.get(email).add(account.get(1));
            }
        }
        
        // DFS to find component
        Set<String> seen = new HashSet<>();
        List<List<String>> res = new ArrayList<>();
        for(String email: graph.keySet()) {
            if(!seen.contains(email)) {
                List<String> component = new ArrayList<>();
                Deque<String> stack = new ArrayDeque<>();
                stack.push(email);  // åŒæ—¶åŠ å…¥Stackå’Œseen setä¸­
                seen.add(email);
                while(!stack.isEmpty()) {
                    String node = stack.pop();
                    component.add(node);
                    for(String nei: graph.get(node)) {
                        if(!seen.contains(nei)) {
                            stack.push(nei);  // åŒæ—¶åŠ å…¥Stackå’Œseen setä¸­
                            seen.add(nei);
                        }
                    }
                }
                Collections.sort(component);
                component.add(0, emailToName.get(email));
                res.add(component);
            }
        }
        return res;
    }
}
```
![complexity](images/721_DFS_complexity.png)



## Method 2. Union Find (39ms, beat 41%)

```java
class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        DSU dsu = new DSU();
        Map<String, String> emailToName = new HashMap<>();
        Map<String, Integer> emailToID = new HashMap<>();
        
        int id = 0;
        for(List<String> account: accounts) {
            String name = "";
            for(String email: account) {
                if(name == "") {
                    name = email;
                    continue;
                }
                emailToName.put(email, name);
                if(!emailToID.containsKey(email)) { // make sure each email just has one and only one ID
                    emailToID.put(email, id++);
                }
                dsu.union(emailToID.get(account.get(1)), emailToID.get(email));
            }
        }
        
        Map<Integer, List<String>> ans = new HashMap<>();
        for(String email: emailToName.keySet()) {   
            int idx = dsu.find(emailToID.get(email));   // The emails belong to one component have the same ID
            if(!ans.containsKey(idx)) {
                ans.put(idx, new ArrayList<>());
            }
            ans.get(idx).add(email);
        }
        
        for(List<String> component: ans.values()) {
            Collections.sort(component);
            component.add(0, emailToName.get(component.get(0)));
        }
        return new ArrayList(ans.values());
    }
}

class DSU {
    int[] parent;
    
    public DSU() {
        parent = new int[10001];
        for(int i=0; i<=10000; i++) {
            parent[i] = i;
        }
    }
    
    public int find(int x) {
        if(parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    public void union(int x, int y) {
        parent[find(x)] = find(y);
    }
}
```
