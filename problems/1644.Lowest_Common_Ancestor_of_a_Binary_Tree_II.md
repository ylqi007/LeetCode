[1644. Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/)

* Tree, Binary Tree, Depth-First Search
* Meta, LinkedIn, Microsoft
* Similar Questions:


**Note:**
1. All `node.val` are unique.
2. `p != q`

ä»¥ä¸Šä¸¤ä¸ªæ¡ä»¶è¯´æ˜ï¼Œ`p` or `q` å¯èƒ½æ ¹æœ¬å°±ä¸åœ¨Treeä¸­ã€‚ä½†æ˜¯åœ¨é¢˜ç›®LC 236ä¸­ï¼Œboth `p` and `q` existã€‚

## Analysis
ç»™å®šä¸€æ£µäºŒå‰æ ‘(Binary Tree)å’Œä¸¤ä¸ªå¯ä¸ºç©ºçš„èŠ‚ç‚¹(`p` and `q`)ï¼Œæ‰¾å‡ºLowest Common Ancestorã€‚æ ¹æ®`p`å’Œ`q`çš„æƒ…å†µï¼Œæœ‰6ç§casesã€‚

ä¸‹é¢çš„ä»£ç ç‰‡æ®µæ¥è‡ª[LC 1644 Editorial](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/editorial/)ï¼Œ
```Java
private TreeNode LCA(TreeNode node, TreeNode p, TreeNode q) {
    if (node == null || node == p || node == q)
        return node;
    TreeNode left = LCA(node.left, p, q);
    TreeNode right = LCA(node.right, p, q);
    if (left != null && right != null)
        return node;
    else if (left != null)
        return left;
    else
        return right;
}
```
This solution doesn't account for the cases where `p` or `q` are not in the binary tree. [å³è¯¥æ–¹æ³•æ— æ³•è§£é‡Šå½“`p` or `q`ä¸å­˜åœ¨çš„æƒ…å†µ]ã€‚
In this solution, the stopping condition is `if(root == null || root == p || root == q) return root`. This means if we encounter `p`, we won't explore the subtrees as we immediately return. If `q` does not exist in the subtree of `p`, we will never know. For cases 4 and 5, this method will return p and q respectively, which is incorrect as we should be returning null instead. [å‚è€ƒä»¥ä¸‹å¯¹6 casesçš„åˆ†æ]

**Case1:** `p` and `q`éƒ½å­˜åœ¨ï¼Œåˆ‡èƒ½æ‰¾åˆ°LCAã€‚
![](images/1644_Case1.png)

**Case2:** `q`åœ¨ä»¥`p`ä¸ºæ ¹èŠ‚ç‚¹çš„subtreeä¸­
![](images/1644_Case2.png)

**Case3:** `p`åœ¨ä»¥`q`ä¸ºæ ¹èŠ‚ç‚¹çš„subtreeä¸­
![](images/1644_Case3.png)

**Case4:** `p`å­˜åœ¨ï¼Œä½†æ˜¯`q`æ˜¯`null`
![](images/1644_Case4.png)
When returning `p` as the lowest common ancestor, we can check for `q` in the subtree of `p` to ensure that both the nodes are present. å³å½“è¿”å›`p`ä½œä¸ºLCAæ—¶ï¼Œç»§ç»­æ£€æŸ¥`q`æ˜¯å¦åœ¨`p`çš„å­æ ‘ç§ã€‚

**Case5:** `q`å­˜åœ¨ï¼Œä½†æ˜¯`p`æ˜¯`null`ã€‚ä¸Case4çš„æƒ…å†µä¸€è‡´ã€‚
![](images/1644_Case5.png)
Likewise, for the case where this method returns `q` as the lowest common ancestor we can check for `p` in the subtree of `q` to ensure that both nodes are present.

**Case6:** `p`å’Œ`q`éƒ½ä¸å­˜åœ¨ã€‚
![](images/1644_Case6.png)
If this method returns `null`, it indicates that neither `p` nor `q` are present in the tree.


## Method 1. LCA + DFS (16ms)
**Intuition:**
1. `LCA()`æ˜¯ä¸ºäº†æ‰¾lowest common ancestorã€‚ä½†æ˜¯ç”±äºå…¶ä¸­çš„`p` or `q`å¯èƒ½ä¸å­˜åœ¨ï¼Œæ‰€ä»¥è¿˜éœ€è¦`dfs()`ç¡®è®¤æ˜¯å¦`p` and `q`éƒ½å­˜åœ¨ã€‚
2. `dfs()`æ˜¯ä¸ºäº†ç¡®è®¤`p` and `q`éƒ½å­˜åœ¨ã€‚
```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode res = LCA(root, p, q);
        if(res == p) {  
            return dfs(p, q) ? p : null;   // Check if q is in the subtree of p
        } else if(res == q) {   
            return dfs(q, p) ? q : null;   // Check if p is in the subtree of q
        } 
        return res;
    }

    private TreeNode LCA(TreeNode node, TreeNode p, TreeNode q) {
        if(node == null || node == p || node == q) {
            return node;
        }

        TreeNode left = LCA(node.left, p, q);
        TreeNode right = LCA(node.right, p, q);

        if(left != null && right != null) {
            return node;
        } else if(left != null) {
            return left;
        } else {
            return right;
        }
    }

    private boolean dfs(TreeNode node, TreeNode target) {
        if(node == target) {
            return true;
        }
        if(node == null) {
            return false;
        }
        return dfs(node.left, target) || dfs(node.right, target);
    }
}
```
**Complexity Analysis:**
Let `N` be the total number of nodes in the tree.
1. Time complexity: `O(N)`. In the worst case we will go over the whole tree, for example when both `p` and `q` are not present in the tree.
2. Space complexity: `O(N)`. This is the stack space used by the solution when performing depth first search over the tree. The max depth will be the height of the tree. In the worst case, height will be `N` when all the nodes form a chain.


## ğŸŸ©ğŸŒŸMethod 2. Depth First Search - 2/3 Conditions (8ms, beats 51%)
**Intuition:**
How can we confirm that `p` and `q` are present in the tree? 
For any given node, if any two of the following three conditions hold true, we can say that p and q are both present in the tree.
    1. node is either `p` or `q`
    2. `p` or `q` is in the left subtree of node
    3. `p` or `q` is in the right subtree of node

åªè¦ä»¥ä¸Šæ»¡è¶³ä»¥ä¸Šä¸‰ä¸ªæ¡ä»¶ä¸­çš„ä»»æ„ä¸¤ä¸ªï¼Œå°±è¯´æ˜`p`å’Œ`q`éƒ½å­˜åœ¨ã€‚

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private boolean nodesFound = false;

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode res = dfs(root, p, q);
        return nodesFound ? res : null;
    }

    private TreeNode dfs(TreeNode node, TreeNode p, TreeNode q) {
        if(node == null) {
            return null;
        }

        TreeNode left = dfs(node.left, p, q);
        TreeNode right = dfs(node.right, p, q);
        
        int conditions = 0;
        if(node == p || node == q) {
            conditions++;
        }
        if(left != null) {
            conditions++;
        }
        if(right != null) {
            conditions++;
        }
        if(conditions == 2) {
            nodesFound = true;
        }

        if((left != null && right != null) || node == p || node == q) {
            return node;
        }
        return left != null ? left : right;    
    }
}
```
**Complexity Analysis:**
Let `N` be the total number of nodes in the tree.
1. Time complexity: `O(N)`. In the worst case we will go over the whole tree, for example when both `p` and `q` are not present in the tree.
2. Space complexity: `O(N)`. This is the stack space used by the solution when performing depth first search over the tree. The max depth will be the height of the tree. In the worst case, height will be `N` when all the nodes form a chain.

or my improved version below
1. When both nodes exist in `root.left`, then only `left == 1`, then the total count will be 1
```java
class Solution {

    private TreeNode res;

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root, p, q);
        return res;
    }

    private boolean dfs(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) {
            return false;
        }
        int left = dfs(root.left, p, q) ? 1 : 0;
        int right = dfs(root.right, p, q) ? 1 : 0;
        int mid = (root == p || root == q) ? 1 : 0;

        // Only when left+right+mid == 2, root is the lowest common ancestor
        if(left + right + mid == 2) {
            res = root;
        }
        return left + right + mid > 0;
    }
}
```


## Method 3. 7ms
```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {

    int count = 0;

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(p == q) return p;
        TreeNode res = lca(root, p, q);
        return count == 2? res : null;
    }

    public TreeNode lca(TreeNode node, TreeNode p, TreeNode q){
        if(node == null) return null;
        int flag = 0;
        if(node == p || node == q){ // æ ‡è®°ä½†ä¸è¿”å›ï¼Œå› ä¸ºå¦ä¸€ä¸ªp/qå¯èƒ½æ˜¯ä»–çš„å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥è¦ç»§ç»­éå†
            count += 1;
            flag = 1;
        }

        TreeNode left = lca(node.left, p, q);
        TreeNode right = lca(node.right, p, q);

        if((left != null && right != null) || flag == 1) return node;
        if(left != null) return left;
        return right; // è¿™é‡Œè·³æ­¥äº†å“ˆ
    }
}
```
* https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/submissions/1134036677/


## Reference
1. https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/editorial/
2. https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/submissions/1134036677/