[162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)


* Facebook, Amazon, Google, Apple
* Array, Binary Search
* Similar Questions:
    * Peak Index in a Mountain Array
    
    
## Method 1.
```java 
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while(left < right) {
            int mid = left + ((right - left) >> 1);
            if(nums[mid] < nums[mid+1]) {   // nums[mid] cannot be the peak
                left = mid + 1;
            } else {    // nums[mid] >= nums[mid+1]
                right = mid;
            }
        }   // After the while loop, left >= right
        return left;
    }
}
```


## 总结
> 除了本文所介绍的二分查找的应用方式，二分查找其实还有很多其他的变体和应用，但它们基本上是**循环条件**，**判断条件**，**边界更新方法**的不同组合，
> 例如，有的二分查找的循环条件可以是 `while(left + 1 < right)`，有的边界的更新的条件需要依赖 `nums[left]`, `nums[mid]`, `nums[mid+1]`, `nums[right]`四个值的相互关系。

| 查找方式        | 循环条件           | 左侧更新           | 右侧更新           | 中间点位置                             | 返回值         |
| :--------:     | :-------:         | :-------:         | :-------:         | :---------:                           | :-----:       |
| 标准二分查找    | `left <= right`   | `left = mid - 1`  | `right = mid + 1` | `left + ((right - left) >> 1)`        | `-1/mid`      |
| 二分找左边界    | `left < right`    | `left = mid - 1`  | `right = mid`     | `left + ((right - left) >> 1)`        | `-1/left`     |
| 二分找右边界    | `left < right`    | `left = mid`      | `right = mid - 1` | `left + ((right - left) >> 1) + 1`    | `-1/right`    |


## LeetCodes
* 1283
* 1011
* 875
* 774
