[272. Closest Binary Search Tree Value II](https://leetcode.com/problems/closest-binary-search-tree-value-ii/)

* LinkedIn, Facebook
* Stack, Tree
* Similar Questions:
    * 94.Binary Tree Inorder Traversal
    * 270.Closest Binary Search Tree Value
* Hints:
    * Consider implements two helper functions:
        1. `getPredecessor(N)`, which returns the next smaller node to N;
        2. `getSuccessor(N)`, which returns the next larger node to N.
    * Try to assume that each node has a parent pointer, it makes the problem much easier.
    * Without parent pointer we just need to keep track of the path from the root to the current node using a stack.
    * You would need two stack to track the path in finding predecessor and successor node separately.
        
    
## Method 1. [AC clean Java solution using two stacks](https://leetcode.com/problems/closest-binary-search-tree-value-ii/discuss/70511/AC-clean-Java-solution-using-two-stacks)
* Inorder traversal of BST gives us sorted predecessors, whereas reverse-inorder traversal gives us sorted successors.
* 也就是 BST 的 inorder traversal 是升序的，而 reverse-inorder traversal 则是降序的。

```java 
class Solution {
    public List<Integer> closestKValues(TreeNode root, double target, int k) {
        List<Integer> res = new ArrayList<>();
        
        Stack<Integer> stack1 = new Stack<>();  // predecessors
        Stack<Integer> stack2 = new Stack<>();  // successors
        
        inorder(root, target, false, stack1);
        inorder(root, target, true, stack2);
        
        while(k-- > 0) {    // k represent the no. of elements we need. therefore, if k>0, keep adding elements to res.
            if(stack1.isEmpty()) {
                res.add(stack2.pop());
            } else if(stack2.isEmpty()) {
                res.add(stack1.pop());
            } else if(Math.abs(stack1.peek() - target) < Math.abs(stack2.peek() - target)) {
                res.add(stack1.pop());
            } else {
                res.add(stack2.pop());
            }
        }
        
        return res;
    }
    
    // inorder traversal
    private void inorder(TreeNode root, double target, boolean reverse, Stack<Integer> stack) {
        if(root == null) {
            return;
        }
        
        inorder(reverse ? root.right : root.left, target, reverse, stack);  // handle left or right subtree depends on inorder or reverse-inorder
        // Early terminate, no need to traverse the whole tree
        if((reverse && root.val <= target) || (!reverse && root.val > target)) {    // if (reverse && root.val<=target), then stop, which we only need to find elements larger than target, ==> successor
            return;                                                                 // if (!reverse && root.val>target), then stop, which we only need to find elements smaller than target, ==> predecessor    
        }
        // Track the value of current node
        stack.push(root.val);
        inorder(reverse ? root.left : root.right, target, reverse, stack);
    }
}
```
Complexity:
    
    Time: O(N)
    Space: O(N)
    
    
## Method 2. [ref](https://leetcode.com/problems/closest-binary-search-tree-value-ii/discuss/70511/AC-clean-Java-solution-using-two-stacks/200478)
```java 
class Solution {
    public List<Integer> closestKValues(TreeNode root, double target, int k) {
        Stack<TreeNode> smaller = new Stack<>();
        Stack<TreeNode> larger = new Stack<>();
        pushSmaller(root, target, smaller);
        pushLarger(root, target, larger);
        
        List<Integer> res = new ArrayList<>();
        TreeNode cur = null;
        while (res.size() < k) {
            if (smaller.isEmpty() || (!larger.isEmpty() && larger.peek().val - target < target - smaller.peek().val)) {
                cur = larger.pop();
                res.add(cur.val);
                pushLarger(cur.right, target, larger);
            } else {
                cur = smaller.pop();
                res.add(cur.val);
                pushSmaller(cur.left, target, smaller);
            }
        }
        return res;    
    }
    
    private void pushSmaller(TreeNode node, double target,  Stack<TreeNode> stack) {
        while (node != null) {
            if (node.val < target) {
                stack.push(node);
                node = node.right;
            } else {
                node = node.left;
            }
        }
    }
    
    private void pushLarger(TreeNode node, double target, Stack<TreeNode> stack) {
        while (node != null) {
            if (node.val >= target) {
                stack.push(node);
                node = node.left;
            } else {
                node = node.right;
            }
        }
    }
}
```

